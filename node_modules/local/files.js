var fs = require('fs'),
    path = require('path'),
    im = require('imagemagick'),
    exec = require('child_process').exec;

/* ---- Base functions ---- */

function prepareDir(fileName, basePath) {
    var d = Q.defer(),
        fullBasePath = PATHS.UPLOADS + (basePath[0] === '/' ? '' : '/') + basePath,
        firstDirName = (path.basename(fileName, '.jpg').substr(0, 2) + '00').substr(0, 2),
        secondDirName = (path.basename(fileName, '.jpg').substr(2, 2) + '00').substr(0, 2),
        firstDirPath = fullBasePath + '/' + firstDirName,
        secondDirPath = firstDirPath + '/' + secondDirName;

    fs.mkdir(firstDirPath, '0755', function(err) {
        if (!err || err.errno === 47) {
            fs.mkdir(secondDirPath, '0777', function(err) {
                if (!err || err.errno === 47) d.resolve(secondDirPath);
                else d.reject(err);
            });
        }
        else {
            d.reject(err);
        }
    });

    return d.promise;
}

function writeFile(fileName, fileData, basePath) {
    var d = Q.defer();

    prepareDir(fileName, basePath).then(function(path) {
        fs.writeFile(path + '/' + fileName, fileData, 'binary', function(err) {
            if (!err) d.resolve();
            else d.reject(err);
        });
    }, function(err) {
        d.reject(err);
    }).done();

    return d.promise;
}

function copyFile(oldFilePath, newPath, deleteOld) {
    var d = Q.defer(),
        fileName = path.basename(oldFilePath);

    prepareDir(fileName, newPath).then(function(path) {
        var readStream = fs.createReadStream(oldFilePath);

        readStream.pipe(fs.createWriteStream(path + '/' + fileName));

        readStream.on('end', function() {
            if (deleteOld) deleteFile(oldFilePath);

            // No wait until deleting is complete.
            d.resolve();
        });

        readStream.on('error', function(err) {
            d.reject(err);
        });
    }, function(err) {
        d.reject(err);
    }).done();

    return d.promise;
}

function deleteFile(filePath) {
    var d = Q.defer();

    fs.unlink(filePath, function(err) {
        if (!err) d.resolve();
        else d.reject(err);
    });

    return d.promise;
}

// fileName: file name
// fileType: 'avatar' || 'post-image' || 'post-video'
// fileSize: 'small' || 'medium' || 'original' (for image files)
function getFilePath(fileName, fileType, fileSize, excludeFileName) {
    var basePath,
        firstDirName = (path.basename(fileName, '.jpg').substr(0, 2) + '00').substr(0, 2),
        secondDirName = (path.basename(fileName, '.jpg').substr(2, 2) + '00').substr(0, 2);

    switch (fileType) {
        case 'avatar':
            basePath = '/avatars/' + (fileSize || 'medium');
            break;
        case 'post-image':
            basePath = '/posts/images/' + (fileSize || 'medium');
            break;
        case 'post-video':
            basePath = '/posts/video';
            break;
        default:
            throw new Error('wrong-file-type');
    }

    return basePath + '/' + firstDirName + '/' + secondDirName + (!excludeFileName ? '/' + fileName : '');
}

/* ---- End: Base functions ---- */


/* ---- Base model functions ---- */

function getFileModel(fileName, attachmentToken) {
    var d = Q.defer(),
        filter = { name: fileName };

    if (attachmentToken) filter.attachmentToken = attachmentToken;

    models.Files.findOne(filter, function(err, file) {
        if (!err && file) d.resolve(file);
        else if (!err) d.reject(new Error('file-missed'));
        else d.reject(err);
    });

    return d.promise;
}

function updateFileStatusToStable(fileModel) {
    var d = Q.defer();

    fileModel.status = 2;

    fileModel.save(function (err, savedFile) {
        if (!err) d.resolve(savedFile);
        else d.reject(err);
    });

    return d.promise;
}

/* ---- End: Base model functions ---- */


/* ---- Specific functions ---- */

function handleAvatar(filePath, options) {
    var size,
        d = Q.defer();

    switch (options && options.size) {
        case 'small':
            size = 40;
            break;
        case 'medium':
        default:
            size = 120;
            break;
    }

    im.identify(filePath, function(err, features) {
        if (!err) {
            im.crop({
                srcPath: filePath,
                width: size,
                height: size,
                quality: 1
            }, function(err, stdout, stderr) {
                if (!err) {
                    d.resolve(stdout);
                }
                else {
                    d.reject(err);
                }
            });
        }
        else {
            d.reject(err);
        }
    });

    return d.promise;
}

function handlePostImage(filePath, options) {
    var maxSize,
        d = Q.defer();

    switch (options && options.size) {
        case 'small':
            maxSize = 40;
            break;
        case 'medium':
        default:
            maxSize = 200;
            break;
    }

    im.identify(filePath, function(err, features) {
        var w, h, newW, newH;

        if (!err) {
            w = features.width;
            h = features.height;

            if (w > h) {
                newW = maxSize;
                newH = newW / (w / h);
            }
            else {
                newH = maxSize;
                newW = newH / (h / w);
            }

            exec([
                'convert',
                filePath,
                PATHS.PUBLIC + '/images/watermark.png',
                // '-watermark', '20%',
                // '-dissolve', '20%',
                '-gravity', 'SouthEast',
                '-geometry', '+15+10',
                '-quality', 100,
                '-composite', filePath
            ].join(' '), function(err, stdout, stderr) {
                if (!err) {
                    im.resize({
                        srcPath: filePath,
                        width: newW,
                        height: newH,
                        quality: 100
                    }, function(err, stdout, stderr) {
                        if (!err) {
                            d.resolve(stdout);
                        }
                        else {
                            d.reject(err);
                        }
                    });
                }
                else {
                    d.reject(err);
                }
            });
        }
        else {
            d.reject(err);
        }
    });

    return d.promise;
}

function linkAvatarToUser(fileId, userId) {
    var d = Q.defer();

    models.Profile.findById(userId, function(err, doc) {
        if (!err && doc) {
            doc.avatar = fileId;

            doc.save(function (err, savedDoc) {
                if (!err) {
                    d.resolve();
                }
                else {
                    d.reject(err);
                }
            });
        }
        else if (!err) {
            d.reject('Can\'t find user for update avatar.');
        }
        else {
            d.reject(err);
        }
    })

    return d.promise;
}

/* ---- End: Specific functions ---- */


/* ---- Flows ---- */


// fileName: file name
// fileType: 'avatar' || 'post-image' || 'post-video'
// attachmentToken: attachmentToken
// userId: user id, for avatars only
function resolveTempFile(fileName, fileType, attachmentToken, userId) {
    var fileModel,
        d = Q.defer();

    getFileModel(fileName, attachmentToken).then(function(model) {
        var result;

        fileModel = model;

        switch(fileType) {
            case 'avatar':
                result = resolveAvatar(fileName);
                break;
            case 'post-image':
                result = resolvePostImage(fileName);
                break;
            case 'post-video':
                result = resolvePostVideo(fileName);
                break;
            default:
                throw new Error('wrong-file-type');
        }

        return result;
    }).then(function() {
        return updateFileStatusToStable(fileModel);
    }).then(function(model) {
        fileModel = model;

        switch(fileType) {
            case 'avatar':
                linkAvatarToUser(fileModel.id, userId).then(function() {
                    d.resolve(model.toJSON({ virtuals: true }));
                }, function(err) {
                    d.reject(err);
                }).done();

                break;
            case 'post-image':
            case 'post-video':d
            default:
                d.resolve(model.toJSON({ virtuals: true }));
                break;
        }

    }, function(err) {
        d.reject(err);
    }).done();

    return d.promise;
}

function resolveAvatar(fileName) {
    return resolveImageHelper(fileName, 'avatar');
}

function resolvePostImage(fileName) {
    return resolveImageHelper(fileName, 'post');
}

function resolvePostVideo(fileName) {
    var d = Q.defer(),
        filePath = PATHS.UPLOADS + '/' + fileName;

    fs.exists(filePath, function(exists) {
        if (exists) {
            copyFile(filePath, '/posts/video', true).then(function() {
                d.resolve();
            }, function(err) {
                d.reject(err);
            });
        }
        else {
            d.reject(new Error('file-missed'));
        }
    });

    return d.promise;
}

// fileName: file name
// fileType: 'avatar' || 'post'
function resolveImageHelper(fileName, type) {
    var d = Q.defer(),
        filePath = PATHS.UPLOADS + '/' + fileName;

    fs.exists(filePath, function(exists) {
        var smallFileD, middleFileD;

        if (exists) {
            if (type === 'post') {
                smallFileD = handlePostImage(filePath, { size: 'small' });
                middleFileD = handlePostImage(filePath, { size: 'medium' });
            }
            else if (type === 'avatar') {
                smallFileD = handleAvatar(filePath, { size: 'small' });
                middleFileD = handleAvatar(filePath, { size: 'medium' });
            }

            Q.spread([smallFileD, middleFileD], function(smallFile, middleFile) {
                var basePath = type === 'post' ? '/posts/images' : (type === 'avatar' ? '/avatars' : ''),
                    smallWriteD = writeFile(fileName, smallFile, basePath + '/small'),
                    middleWriteD = writeFile(fileName, middleFile, basePath + '/medium'),
                    originalWriteD = copyFile(filePath, basePath + '/original', true);

                Q.spread([smallWriteD, middleWriteD, originalWriteD], function() {
                    d.resolve();
                }, function(err) {
                    d.reject(err);
                }).done();

            }, function(err) {
                d.reject(err);
            }).done();

        }
        else {
            d.reject(new Error('file-missed'));
        }
    });

    return d.promise;
}

/* ---- End: Flows ---- */

module.exports = {
    resolveTempFile: resolveTempFile,
    getFilePath: getFilePath,
    resolveAvatar: resolveAvatar,
    resolvePostImage: resolvePostImage,
    resolvePostVideo: resolvePostVideo
};