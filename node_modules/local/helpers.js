var util = require('util'),
    Helpers = {};

require('./lib/deepExtend.js');

Helpers.extend = function(base, _props, dontCopyProps, recursiveCopyProps) {
    var result,
        props = {};

    recursiveCopyProps = recursiveCopyProps || [];

    Object.keys(_props).forEach(function(propName) {
        var newprop,
            prop = _props[propName];

        if (typeof prop === 'function') {
            newprop = function() {
                var result,
                    tmp = this._super;

                this._super = base[propName] || function() {};
                result = prop.apply(this, arguments);
                this._super = tmp;

                return result;
            }
        }
        else {
            newprop = prop;
        }

        if (!~recursiveCopyProps.indexOf(propName)) {
            props[propName] = {
                value: newprop,
                writable: true,
                enumerable: true,
                configurable: true
            };
        }

        recursiveCopyProps.forEach(function(propName) {
            props[propName] = {
                value: copyRecursiveProp(base, _props, propName),
                writable: true,
                enumerable: true,
                configurable: true
            };
        });
    });

    if (dontCopyProps) {
        Object.keys(dontCopyProps).forEach(function(propName) {
            if (!props.hasOwnProperty(propName)) {
                props[propName] = {
                    value: dontCopyProps[propName],
                    writable: true,
                    enumerable: true,
                    configurable: true
                }; // TODO: clone ?
            }
        });
    }

    function copyRecursiveProp(base, props, propName) {
        var result, baseKeys, newKeys,
            baseProp = base[propName],
            newProp = props[propName];

        if (props.hasOwnProperty(propName)) {
            if (isNativeObject(newProp)) {
                if (base.hasOwnProperty(propName) && isNativeObject(baseProp)) {
                    baseKeys = Object.keys(baseProp);
                    newKeys = Object.keys(newProp);

                    result = {};

                    newKeys.forEach(function(newKey) {
                        result[newKey] = copyRecursiveProp(baseProp, newProp, newKey);
                    });

                    baseKeys.forEach(function(baseKey) {
                        if (!result.hasOwnProperty(baseKey)) result[baseKey] = baseProp[baseKey];
                    });
                }
                else {
                    result = newProp;
                }
            }
            else {
                result = newProp;
            }
        }
        else {
            result = base.hasOwnProperty(propName) ? base[propName] : null;
        }

        return result;
    }

    function isNativeObject(obj) { // !!!
        return typeof obj === 'object' && !util.isArray(obj) && obj !== null;
    }

    result = Object.create(base, props);

    return result;
};

Helpers.extendController = function(base, props, recursiveCopyProps) {
    return Helpers.extend(base, props, {
        name: null,
        isAbstract: false,
        init: null
    }, recursiveCopyProps || null);
};

Helpers.extendCRUDController = function(base, props) {
    return Helpers.extendController(base, props, ['proxy', 'create', 'read', 'update', 'delete']);
};

Helpers.getArray = function(obj) {
    return [].concat(obj || []);
};

Helpers.generateRandomToken = function() {
    var x, i,
        chars = "_!abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890",
        token = new Date().getTime() + '_';

    for (x = 0; x < 16; x++) {
        i = Math.floor(Math.random() * 62);
        token += chars.charAt(i);
    }

    return token;
};

Helpers.randomChance = function(chance) {
    return Math.random() < (chance * 0.01);
};

Helpers.randomBetween = function(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min
};

Helpers.randomFromArray = function(arr, chance) {
    return arr.filter(function(item) {
        return Helpers.randomChance(chance);
    });
};

Helpers.capitalize = function(string) {
    return string.charAt(0).toUpperCase() + string.slice(1);
};

Helpers.isNumber = function(n) {
    return !isNaN(parseFloat(n)) && isFinite(n);
};

Helpers.isEmpty = function(val) {
	var type = typeof val;

    if (null === val) {
        return true;
    }
	else if ('undefined' == type) {
		return true;
	}
	else if ('string' == type) {
		return '' === val;
	}
	else if ('object' == type) {
		return !Object.keys(val).length;
	}

	return false;
};


Helpers.truncate = function(string, count, useHellip, useWordBoundary) {
	var toLong = string.length > count,
		s_ = toLong ? string.substr(0, count-1) : string;

	s_ = useWordBoundary && toLong ? s_.substr(0, s_.lastIndexOf(' ')) : s_;

	return  toLong ? s_ + (useHellip && toLong ? '&hellip;' : '') : s_;
};

Helpers.date2Text = function(date) {
    var result,
        now = new Date(),
        diff = now - date,
        ranges = {};

    ranges.minute = 1000 * 60;
    ranges.hour = ranges.minute * 60;
    ranges.day = ranges.hour * 24;
    ranges.week = ranges.day * 7;
    ranges.month = ranges.day * 30;
    ranges.year = ranges.day * 365.25;

    Object.keys(ranges).reverse().forEach(function(rangeName) {
        var count,
            rangeLength = ranges[rangeName];

        if (!result) {
            if (diff > rangeLength) {
                count = Math.floor(diff / rangeLength);

                result = count + ' ' + rangeName + (count > 1 ? 's' : '') + ' ago';
            }
        }
    });

    if (!result) {
        result = 'less than a minute ago';
    }

    return result;
};

module.exports = Helpers;